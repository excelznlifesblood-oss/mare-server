# azure-pipelines.yml â€” build & deploy Shonin Sync services to your Ubuntu box

parameters:
- name: app
  displayName: Which app(s)?
  type: string
  default: all
  values:
  - all
  - discord
  - server
  - auth
  - files

- name: deploy
  displayName: Deploy after build?
  type: boolean
  default: true

trigger:
  branches:
    include:
    - main
  paths:
    include:
    - MareSynchronosServer/**
    - azure-pipelines.yml

pr:
  branches:
    include:
    - main

variables:
  DOTNET_SDK: '9.0.x'
  SSH_CONN: 'racknerd'
  REMOTE_INCOMING: '/shoninsync/_incoming'

  # Project paths
  DISCORD_PROJECT: 'MareSynchronosServer/MareSynchronosServices/MareSynchronosServices.csproj'
  SERVER_PROJECT:  'MareSynchronosServer/MareSynchronosServer/MareSynchronosServer.csproj'
  AUTH_PROJECT:    'MareSynchronosServer/MareSynchronosAuthService/MareSynchronosAuthService.csproj'
  FILES_PROJECT:   'MareSynchronosServer/MareSynchronosStaticFilesServer/MareSynchronosStaticFilesServer.csproj'

  # Existing server dirs
  DISCORD_REMOTE_DIR: '/shoninsync/services'
  SERVER_REMOTE_DIR:  '/shoninsync/server'
  AUTH_REMOTE_DIR:    '/shoninsync/auth'
  FILES_REMOTE_DIR:   '/shoninsync/files'

  # Existing systemd units (without .service suffix)
  DISCORD_UNIT: 'shonin-services'
  SERVER_UNIT:  'shonin-server'
  AUTH_UNIT:    'shonin-auth'
  FILES_UNIT:   'shonin-files'

stages:
# ===================== Build =====================
- stage: Build
  displayName: "Build & package"
  jobs:
  - job: build_linux
    displayName: "Build on Ubuntu"
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: self
      clean: true

    - task: UseDotNet@2
      displayName: "Use .NET SDK $(DOTNET_SDK)"
      inputs:
        packageType: sdk
        version: $(DOTNET_SDK)

    # Authenticate to Azure Artifacts (for private NuGet feed)
    - task: NuGetAuthenticate@1
      displayName: "Authenticate to Azure Artifacts"

    # Create nuget.config with nuget.org + your private feed
    - task: Bash@3
      displayName: "Write nuget.config with ShoninSync feed"
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          cat > "$(Build.SourcesDirectory)/nuget.config" <<'EOF'
          <?xml version="1.0" encoding="utf-8"?>
          <configuration>
            <packageSources>
              <add key="nuget.org" value="https://api.nuget.org/v3/index.json" />
              <add key="ShoninSync" value="https://excelzn.pkgs.visualstudio.com/000133ad-8b16-41ad-9d35-5040d0cd2c2f/_packaging/ShoninSync/nuget/v3/index.json" />
            </packageSources>
          </configuration>
          EOF
          echo "nuget.config created at $(Build.SourcesDirectory)/nuget.config"

    # ---- Discord bot ----
    - task: Bash@3
      displayName: "Build discord bot"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','discord')))
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          proj='$(DISCORD_PROJECT)'
          out='$(Build.ArtifactStagingDirectory)/discord/app'
          rm -rf "$out"
          dotnet restore "$proj" --configfile "$(Build.SourcesDirectory)/nuget.config"
          dotnet publish "$proj" -c Release -o "$out" --no-restore
          tar -C "$out" -czf "$(Build.ArtifactStagingDirectory)/discord.tar.gz" .

    - task: PublishPipelineArtifact@1
      displayName: "Publish artifact: discord"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','discord')))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/discord.tar.gz'
        artifact: 'discord'

    # ---- Main server ----
    - task: Bash@3
      displayName: "Build main server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','server')))
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          proj='$(SERVER_PROJECT)'
          out='$(Build.ArtifactStagingDirectory)/server/app'
          rm -rf "$out"
          dotnet restore "$proj" --configfile "$(Build.SourcesDirectory)/nuget.config"
          dotnet publish "$proj" -c Release -o "$out" --no-restore
          tar -C "$out" -czf "$(Build.ArtifactStagingDirectory)/server.tar.gz" .

    - task: PublishPipelineArtifact@1
      displayName: "Publish artifact: server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','server')))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/server.tar.gz'
        artifact: 'server'

    # ---- Auth server ----
    - task: Bash@3
      displayName: "Build auth server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','auth')))
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          proj='$(AUTH_PROJECT)'
          out='$(Build.ArtifactStagingDirectory)/auth/app'
          rm -rf "$out"
          dotnet restore "$proj" --configfile "$(Build.SourcesDirectory)/nuget.config"
          dotnet publish "$proj" -c Release -o "$out" --no-restore
          tar -C "$out" -czf "$(Build.ArtifactStagingDirectory)/auth.tar.gz" .

    - task: PublishPipelineArtifact@1
      displayName: "Publish artifact: auth"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','auth')))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/auth.tar.gz'
        artifact: 'auth'

    # ---- Files server ----
    - task: Bash@3
      displayName: "Build files server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','files')))
      inputs:
        targetType: inline
        script: |
          set -euo pipefail
          proj='$(FILES_PROJECT)'
          out='$(Build.ArtifactStagingDirectory)/files/app'
          rm -rf "$out"
          dotnet restore "$proj" --configfile "$(Build.SourcesDirectory)/nuget.config"
          dotnet publish "$proj" -c Release -o "$out" --no-restore
          tar -C "$out" -czf "$(Build.ArtifactStagingDirectory)/files.tar.gz" .
    - task: PublishPipelineArtifact@1
      displayName: "Publish artifact: files"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','files')))
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/files.tar.gz'
        artifact: 'files'

# ===================== Deploy =====================
- stage: Deploy
  displayName: "Deploy to Ubuntu"
  dependsOn: Build
  condition: and(succeeded(), ${{ parameters.deploy }})
  jobs:
  - job: deploy_job
    displayName: "Deploy selected app(s)"
    pool:
      vmImage: ubuntu-latest
    steps:
    # Downloads
    - download: current
      displayName: "Download artifact: discord"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','discord')))
      artifact: discord
    - download: current
      displayName: "Download artifact: server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','server')))
      artifact: server
    - download: current
      displayName: "Download artifact: auth"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','auth')))
      artifact: auth
    - download: current
      displayName: "Download artifact: files"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','files')))
      artifact: files

    # Prepare incoming dir + deploy helper
    - task: SSH@0
      displayName: "Prepare incoming dir + deploy helper"
      inputs:
        sshEndpoint: $(SSH_CONN)
        runOptions: inline
        inline: |
          set -euo pipefail
          # ensure staging + backups roots exist (owned by the deploy user)
          mkdir -p "$(REMOTE_INCOMING)"
          mkdir -p "/shoninsync/_backups"
          cat > /tmp/deploy_inplace.sh << 'EOS'
          #!/usr/bin/env bash
          set -euo pipefail
          UNIT="$1"; DIR="$2"; TAR="$3"; TS="$(date +%Y%m%d%H%M%S)"
          BACKUP_DIR="/shoninsync/_backups/$UNIT"
          BACKUP="$BACKUP_DIR/$TS.tgz"

          echo "[deploy] unit=$UNIT dir=$DIR tar=$TAR"
          sudo systemctl stop "$UNIT" || true

          # make backup OUTSIDE the target dir to avoid tar warnings
          mkdir -p "$BACKUP_DIR"
          if [ -d "$DIR" ]; then
            tar -C "$DIR" -czf "$BACKUP" . || true
            echo "[deploy] backup -> $BACKUP"
          fi

          mkdir -p "$DIR"
          tar -C "$DIR" -xzf "$TAR"

          sudo systemctl start "$UNIT"
          if ! sudo systemctl is-active --quiet "$UNIT"; then
            echo "[deploy] start failed; rolling back from $BACKUP"
            if [ -f "$BACKUP" ]; then
              find "$DIR" -mindepth 1 -maxdepth 1 -exec rm -rf {} +
              tar -C "$DIR" -xzf "$BACKUP"
              sudo systemctl start "$UNIT" || true
            fi
            sudo systemctl status "$UNIT" --no-pager -l
            exit 1
          fi
          echo "[deploy] $UNIT running"
          EOS
          chmod +x /tmp/deploy_inplace.sh


    # ---- Discord ----
    - task: CopyFilesOverSSH@0
      displayName: "Upload discord.tar.gz"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','discord')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        sourceFolder: $(Pipeline.Workspace)/discord
        contents: discord.tar.gz
        targetFolder: $(REMOTE_INCOMING)
        overwrite: true
    - task: SSH@0
      displayName: "Deploy discord"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','discord')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        runOptions: inline
        inline: |
          set -euo pipefail
          /tmp/deploy_inplace.sh "$(DISCORD_UNIT)" "$(DISCORD_REMOTE_DIR)" "$(REMOTE_INCOMING)/discord.tar.gz"
          if ! sudo systemctl is-active --quiet "$(DISCORD_UNIT)"; then
            echo "Start FAILED for $(DISCORD_UNIT)"
            sudo journalctl -u "$(DISCORD_UNIT)" --no-pager -n 200
            exit 1
          fi

    # ---- Main server ----
    - task: CopyFilesOverSSH@0
      displayName: "Upload server.tar.gz"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','server')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        sourceFolder: $(Pipeline.Workspace)/server
        contents: server.tar.gz
        targetFolder: $(REMOTE_INCOMING)
        overwrite: true
    - task: SSH@0
      displayName: "Deploy server"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','server')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        runOptions: inline
        inline: |
          set -euo pipefail
          /tmp/deploy_inplace.sh "$(SERVER_UNIT)" "$(SERVER_REMOTE_DIR)" "$(REMOTE_INCOMING)/server.tar.gz"
          if ! sudo systemctl is-active --quiet "$(SERVER_UNIT)"; then
            echo "Start FAILED for $(SERVER_UNIT)"
            sudo journalctl -u "$(SERVER_UNIT)" --no-pager -n 200
            exit 1
          fi

    # ---- Auth ----
    - task: CopyFilesOverSSH@0
      displayName: "Upload auth.tar.gz"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','auth')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        sourceFolder: $(Pipeline.Workspace)/auth
        contents: auth.tar.gz
        targetFolder: $(REMOTE_INCOMING)
        overwrite: true
    - task: SSH@0
      displayName: "Deploy auth"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','auth')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        runOptions: inline
        inline: |
          set -euo pipefail
          /tmp/deploy_inplace.sh "$(AUTH_UNIT)" "$(AUTH_REMOTE_DIR)" "$(REMOTE_INCOMING)/auth.tar.gz"
          if ! sudo systemctl is-active --quiet "$(AUTH_UNIT)"; then
            echo "Start FAILED for $(AUTH_UNIT)"
            sudo journalctl -u "$(AUTH_UNIT)" --no-pager -n 200
            exit 1
          fi

    # ---- Files ----
    - task: CopyFilesOverSSH@0
      displayName: "Upload files.tar.gz"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','files')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        sourceFolder: $(Pipeline.Workspace)/files
        contents: files.tar.gz
        targetFolder: $(REMOTE_INCOMING)
        overwrite: true
    - task: SSH@0
      displayName: "Deploy files"
      condition: and(succeeded(), or(eq('${{ parameters.app }}','all'), eq('${{ parameters.app }}','files')))
      inputs:
        sshEndpoint: $(SSH_CONN)
        runOptions: inline
        inline: |
          set -euo pipefail
          /tmp/deploy_inplace.sh "$(FILES_UNIT)" "$(FILES_REMOTE_DIR)" "$(REMOTE_INCOMING)/files.tar.gz"
          if ! sudo systemctl is-active --quiet "$(FILES_UNIT)"; then
            echo "Start FAILED for $(FILES_UNIT)"
            sudo journalctl -u "$(FILES_UNIT)" --no-pager -n 200
            exit 1
          fi
